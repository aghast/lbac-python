<!DOCTYPE HTML>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="author" content="Austin Hastings" />
    <link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/pygments_borland.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/styles.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/main.js" type="text/javascript"></script>

    <title>Bytecode Generation</title>
  </head>
  <body>
    <header>
      <h1><a href="/">Bytecode Generation</a></h1>
    </header>
    <section>
      <div class="content">
  <div id="chapter">
    <h1></h1>
    <h1 id="toc_3696">Bytecode Generation</h1>

<p>Early in the last chapter we had to choose between adding more
functionality to our expression parser and generating some kind of
executable code with what we already had. We expanded the parser, with a
promise to come back to code generation &#39;later&#39;. Well, it&#39;s later.</p>

<p>In the original series, Crenshaw chose to generate machine code for a
Motorola 68K CPU running SK*DOS -- a system that was pretty much
obsolete when he released the first article. I suppose I could do the
same thing, but how would we be able to test? I need to find a target
architecture that everyone has available to them, no matter what kind of
machine they are using to follow along. Also, it would be nice if it
wasn&#39;t a total pain in the ass to run our generated code.</p>

<p>The solution is pretty obvious, to me. And I hope it won&#39;t bother you
too much: I&#39;ve chosen to stay inside the Python environment, and focus
on generating Python byte codes. Specifically, what is called CPython --
the interpreter written in C and (I hope) available on almost every
system.</p>

<p>There are other Python VM&#39;s: Jython compiles Python down to the byte
codes used by the Java VM. Iron Python compiles Python down to the .NET
CLR. But I&#39;m going to assume that if you have one of those systems, you
probably also have the ability to obtain a CPython package.</p>

<h2 id="toc_3697">Learning the Target Architecture</h2>

<p>Unfortunately, there is no <em>thorough</em> documentation about the workings
of the Python VM. There is no &quot;Architecture Reference Manual&quot; and no
&quot;Assembly Programmer&#39;s Guide&quot; for the Python VM, the way there are for
concrete CPUs and the JVM.</p>

<p>Instead, there is the source code. And some articles available online.
And, of course, you have a copy of the VM available on you desktop if
you need a definitive answer. I&#39;m going to point you at a couple of
references, and one really good resource. After that, it will be
learning-by-doing all over again.</p>

<p>First, there&#39;s a copy of the op-code list in the documentation for the
dis module. And there&#39;s a good set of articles written by Yaniv Aknin
that details some of the internal workings of the interpreter. <a href="http://tech.blog.aknin.name/2010/04/02/pythons-innards-introduction/"><sup>1</sup></a></p>

<p>Next, there are the dis module functions =dis= and =show_code=, and the
builtin =compile= function. Taken together, these are a great resource
to show how a &quot;working&quot; compiler generates bytecode.</p>

<h2 id="toc_3698">Getting Started</h2>

<p>Here&#39;s a good way to get started. Fire up your python interpreter in a
console window:</p>
<div class="highlight"><pre><code class="text">Python 3.3.0 (default, Nov 23 2012, 10:26:01)
[GCC 4.2.1 Compatible Apple Clang 4.1 ((tags/Apple/clang-421.11.66))] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt;
</code></pre>
</div>

<p>At the prompt, first define a simple function:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; def return42():
...     return 42
...
&gt;&gt;&gt;
</code></pre>
</div>

<p>Next, import the two functions dis and show_code from the dis module
as da and sc. Then run both functions on \=return42\=:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; from dis import dis as da, show_code as sc
&gt;&gt; da(return42)
  2           0 LOAD_CONST               1 (42)
              3 RETURN_VALUE
&gt;&gt;&gt; sc(return42)
Name:              return42
Filename:          &lt;stdin&gt;
Argument count:    0
Kw-only arguments: 0
Number of locals:  0
Stack size:        1
Flags:             OPTIMIZED, NEWLOCALS, NOFREE
Constants:
   0: None
   1: 42
&gt;&gt;&gt;
</code></pre>
</div>

<p>This is a great way to learn how to generate byte codes for various
situations. And it&#39;s good to have an idea exactly which flags and values
should be set when we are defining code for the interpreter.</p>

<p>Right now you should define some test functions containing various
control structures. See what the byte code looks like for things like an
if statement, a while loop, a print statement and the like. See what
happens when a function takes parameters. You&#39;ll need to feel
comfortable with the &quot;define and dump&quot; approach we&#39;re taking to learning
about the VM here.</p>

<h2 id="toc_3699">Explaining the VM</h2>

<p>There are a lot of VMs in the world today. The Java VM is probably the
most famous, but pretty much every scripting language (Perl, Python,
Ruby) defines a VM, as does the Microsoft .NET environment. Most (but
not all) of these VMs use what is called a <em>stack architecture.</em></p>

<p>A <em>stack</em> is a concept in computer science also called a LIFO queue.
(LIFO stands for &quot;Last In, First Out&quot;.) The premise is that there is a
queue or list of items being managed by the stack, in such a way that
only the most recently added item is available to viewing or
consumption.</p>

<p>Consider a queue of people buying tickets at a cinema. There may be some
ropes or rails holding it in shape and preventing people from stepping
into (or out of) the middle of the queue. Typically, the tail extends
towards the doors of the cinema (and sometimes right outside!) while the
head of queue is near the ticket booth(s). When a ticket seller becomes
available, they call out &quot;next!&quot; and the person at the head of the queue
steps up to buy tickets.</p>

<p>This is an example of a FIFO queue, short for &quot;First In, First Out&quot;.
People add themmselves to the tail of the queue, and buy tickets when
they reach the head of the queue. Nobody else can buy tickets, and
people in the queue cannot easily step out, or change position, until
they reach the head.</p>

<p>Next consider a street passing through a retail district. In smaller
towns, there will be curb-side parking along the edge of the street,
with cars facing parallel to the flow of traffic. This is the source of
the dreaded &quot;parallel parking&quot; part of the driver&#39;s exam. In such a
scenario, cars can pull in to any unoccupied parking space (if the
driver passed that part of the exam!) and cars can pull out of any
parking space, without regard to other cars parked nearby.</p>

<p>This is an example of a random-access array. The cars are in a definite
&quot;shape&quot; or array. It is possible to assign numbers to the parking spaces
-- for billing, perhaps. But any space can be empty or full at any time,
and drivers can choose to &quot;store&quot; their car into any open space without
regard for where the space is.</p>

<p>Finally, consider a deck of cards. If you turn the deck so that the
faces are up, and then set the deck on the table in front of you, you
will have an example of a stack. You can see only the card at the &quot;top&quot;
of the stack. You can add cards only at the top of the stack. You can
remove cards only by taking them from the top of the stack -- Last In,
First Out. Everything you do must be relative to the top of the stack.</p>

<p>This is the model that the Python VM uses internally for storing data
that it will operate on. There are no &#39;registers&#39;. There is only a
stack. Data can be fetched from variables and placed on top of the
stack. Data that is on top of the stack can be sent off to be stored in
a variable. Operations like add and subtract are performed only using
items on the stack.</p>

<p>For example, let&#39;s write some simple Python code and then disassemble
it, as we did before. Here&#39;s a function that adds a constant to a number
passed in as a parameter:</p>
<div class="highlight"><pre><code class="text">def add20(x):
    return x+20
</code></pre>
</div>

<p>If we define and dump that code, we get this:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; da(add20)
  2           0 LOAD_FAST               0 (x)
              3 LOAD_CONST              1 (20)
              6 BINARY_ADD
              7 RETURN_VALUE
</code></pre>
</div>

<p>Roughly translated, the code reads as follows:</p>

<ol>
<li> Read the value from variables<a href="aka" title="x">0</a> and push it on the stack.</li>
<li> Load the constant from constants<a href="aka%2020">1</a> and push it on the
stack.</li>
<li> Add together the two numbers at the top of the stack, and push the
answer on the stack.</li>
<li> Return the value currently on top of the stack.</li>
</ol>

<p>Back when I was young and dinosaurs roamed the earth there was a series
of Hewlett-Packard calculators that used what is called &quot;RPN&quot; (Reverse
Polish Notation). If you ever used one of those calculators, and had to
enter your expressions like 3,5,+,7,6,+,/ (which is RPN for
&quot;(3+5)/(7+6)&quot;), congratulations! -- you already know how a stack-based
machine works. For the rest of us, I&#39;m afraid we&#39;ll have to struggle
through, occasionally invoking the disassembler to help out.</p>

<p>Here&#39;s how Python computes a similar expression:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; def rpn(a,b,c,d):
...     return (a+b)/(c+d)
...
&gt;&gt;&gt; da(rpn)
  2            0 LOAD_FAST                0 (a)
               3 LOAD_FAST                1 (b)
               6 BINARY_ADD
               7 LOAD_FAST                2 (c)
              10 LOAD_FAST                3 (d)
              13 BINARY_ADD
              14 BINARY_TRUE_DIVIDE
              15 RETURN_VALUE
</code></pre>
</div>

<p>Basically, that translates as <em>put &#39;a&#39; on the stack; put &#39;b&#39; on the
stack; add them; put &#39;c&#39; on the stack; put &#39;d&#39; on the stack; add them;
divide what&#39;s on the stack; return what&#39;s on the stack,</em> which is just
about exactly the same as the steps on that HP calculator.</p>

<h2 id="toc_3700">The Inner Workings</h2>

<p>Spend some time reading the descriptions of the compile and exec
functions in the on-line Python documentation. You&#39;ll find that <em>code
objects</em> are the low-level items that are generated by the compiler, and
are accepted by the bytecode evaluator.</p>

<p>Take a look at the documentation for the inspect function. You&#39;ll find a
list of the internal fields for the various builtin types, including
code objects.</p>

<p>What I have learned from the various sources I have already mentioned is
that the function and method objects are some kind of internal
book-keeping objects. All the &quot;real&quot; details of bytecode storage live in
the code object, which underlies all functions except for the built-in
ones.</p>

<p>The Python VM compiles just about everything as a code object. Defined
functions, obviously, but also module and class definitions. The command
line interpreter also compiles every single line, or group of lines, as
a separate module (which is a code object).</p>

<p>In fact, there doesn&#39;t seem to be any way of executing instructions
without using a code object -- which is fine, it shows us where we will
want to focus our efforts.</p>

<h2 id="toc_3701">Available Libraries</h2>

<p>I did a search for available libraries. There are a few libraries
available for Python 2. In particular, the BytecodeAssembler module by
Phillip J. Eby, and the byteplay package by Noam Yorav-Raphael appear to
do some of what we need done. Unfortunately, they are both targeted at
Python 2, do not offer Python 3 support, and depend enough on
metaprogramming and other weirdness that I didn&#39;t feel comfortable
trying to do a quick port. So instead, we&#39;re going to have to develop
something to help us generate code objects.</p>

<h2 id="toc_3702">Rolling our Own</h2>

<p>In order to develop our own library, we will first need a list of opcode
data. Some of that is available in the online references, particularly
in the documentation of the dis module. But like a lot of VMs, the most
complete specification is the source code itself. There are plenty of
copies of the Python source code available on the web. The code we will
be most interested in lives in a file called Python/ceval.c. That is
where the bytecode interpreter lives.</p>

<p>The data that seems most obvious to me is the name, opcode number
(available in the opcode module), and whether or not the opcode takes an
argument. Reading the opcode list (from the dis module documentation)
reveals the interesting fact that there is a defined constant
HAVE_ARGUMENT that divides the opcodes into those with and those
without arguments.</p>

<p>Given that we know whether an opcode takes an argument or not, we should
be able to write out the correct encoding to a byte array. The byte
array could then become the co_code member of the code object we are
going to generate, and we can then invoke the code we have generated.
Well, there are a few details to take care of, first. (Surprise!)</p>

<p>There are several lists associated with code objects. First, there is
the list of constants. I&#39;m sure you noticed the strange format of the
LOAD_CONST opcodes we have dumped. They looked like this, remember:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; da(return42)
  2           0 LOAD_CONST               1 (42)
              3 RETURN_VALUE
</code></pre>
</div>

<p>The apparent argument to LOAD_CONST is &#39;1&#39;, with a note attached that
it represents the value 42. This is because all bytecode arguments are
16-bit integers. There is no provision for constants that are strings,
or floating point numbers, or lists, or other code objects. Byte code
arguments are always integers.</p>

<p>Secretly, these integers are actually indices into a giant Python
<em>tuple</em> (a fixed, immutable array) that contains all the constants for
this code object. So each code object we define will actually need two
data structures: a string of byte codes, and a list of constants.</p>

<p>But we&#39;re not done yet. In addition to the constants, there are various
data structures dealing with names used by the code object. Names are
not strings -- if you try to print &quot;Hello, world!&quot;, you are using a
string constant. Instead, names are stored in one of the
variable-related tuples: co_varnames, co_cellvars, co_freevars, or
co_names. See the Python&#39;s Innards <a href="http://tech.blog.aknin.name/2010/04/02/pythons-innards-introduction/"><sup>2</sup></a> series for more details.</p>

<p>What does all this mean to us? Well, it means that for simple tasks like
handling constants, we will need to manage the two data structures
already discussed -- the bytecode and the constants tuple. For more
complex tasks involving variables or object member data, we will have to
deal with even more. Since we haven&#39;t done anything with variables just
yet, I think we can put off worrying about it for a while.</p>

<h2 id="toc_3703">Writing a Test Case</h2>

<p>Let&#39;s pretend we have the code already written. Using it looks something
like this:</p>
<div class="highlight"><pre><code class="text">co = CodeObject()
co.append(&#39;LOAD_CONST&#39;, 42)
co.append(&#39;RETURN_VALUE&#39;)
</code></pre>
</div>

<p>How do we test that? What format should we use that is human-writable
and can express the desired result?</p>

<p>I think we should use a format that is close to that generated by the
dis function. First, because it&#39;s basically an assembly language format,
and second, because a lot of our tests are going to come from dumping
what the Python compiler generates. Something like this:</p>
<div class="highlight"><pre><code class="text">from ch03.bytecode import CodeObject

class TestBytecode(unittest.TestCase):
def test_return42(self):
    co = CodeObject()
    co.append(&#39;LOAD_CONST&#39;, 42)
    co.append(&#39;RETURN_VALUE&#39;)
    expected = &quot;&quot;&quot;
    LOAD_CONST      1 (42)
    RETURN_VALUE
    &quot;&quot;&quot;
    self.assertInstructions(co, expected)
</code></pre>
</div>

<p>It will get harder and harder to specify the entire compiled bytecode
string. As we get deeper and deeper into writing a compiler, there will
be more and more &#39;setup&#39; code that we don&#39;t care about but have to have
in order to put the compiler in the state we require. Something like
&quot;does our recursive call in an if-statement get converted to
tail-recursion when we&#39;re inside a method with three parameters in a
class with multiple inheritance?&quot; We may eventually want to assert only
a small subset of the code.</p>

<p>And we will probably get the constant and name indices wrong, since
those will be allocated by the compiler in some order that makes sense
to it, not necessarily to us. So eventually, we will want to be a little
flexible in our specification language. For now, though, it&#39;s good
enough.</p>

<h2 id="toc_3704">Passing the First Test Case</h2>

<p>So let&#39;s write some code! I&#39;ll call the module bytecode, and so there
will be a ch03/bytecode.py and a ch03/tests/bytecode_tests.py file.
Also, create an empty ch03/__init__.py file to make importing work.
We&#39;ll keep the test case we have already written. Not surprisingly, it
won&#39;t pass at first. :</p>
<div class="highlight"><pre><code class="text">import unittest
from ch03 import bytecode

class TestBytecode(unittest.TestCase):

def test_return42(self):
    co = CodeObject()
    co.append(&#39;LOAD_CONST&#39;, 42)
    co.append(&#39;RETURN_VALUE&#39;)
    expected = &quot;&quot;&quot;
        LOAD_CONST      1 (42)
        RETURN_VALUE
    &quot;&quot;&quot;
    self.assertInstrMatch(co, expected)
</code></pre>
</div>

<p>Before we start working on ch03/bytecode.py you should read the
documentation for the opcode module. An in particular, pay attention to
all the little lists that it provides. In the python interpreter, look
at the output of import opcode; dir(opcode) to see them all together.
Those constants (HAVE_ARGUMENT) and lists (hasconst, hasfree) contain
the details about the opcodes. The opmap and opname variables map opcode
numbers to names (opname[x]) and names to numbers
(opmap[&#39;RETURN_VALUE&#39;]). Plan to make use of all this data!</p>

<p>And have a look at the documentation for the inspect module. The section
on code objects details all the fields that a code object can have.
Since that is what we are going to produce, we should probably model it.</p>

<p>Here&#39;s some init code:</p>
<div class="highlight"><pre><code class="text">import opcode

class CodeObject:

def __init__(self, ref=None):
    &quot;&quot;&quot;
    Create a new CodeObject. If =from= is set, take the values from
    the function or code object given. Otherwise, the object should
    be empty but ready to modify.
    &quot;&quot;&quot;
    if ref is None:
    self._modifiable = True
    self.co_argcount = 0
    self.co_code = bytearray()
    self.co_consts = []
    self.co_filename = &#39;&lt;no file&gt;&#39;
    self.co_firstlineno = 1
    self.co_flags = 0
    self.co_lnotab = bytearray()
    self.co_name = &#39;&lt;no name&gt;&#39;
    self.co_names = []
    self.co_nlocals = 0
    self.co_stacksize = 0
    self.co_varnames = []
    else:
    if isinstance(ref, types.CodeType):
        from_co = ref
    elif isinstance(ref, types.FunctionType):
        from_co = ref.__code__
    else:
        raise ValueError(&quot;Don&#39;t know how to handle type: %s&quot; % type(ref))

    self._modifiable = False
    self.co_argcount = co.co_argcount
    self.co_code = co.co_code
    self.co_consts = co.co_consts
    self.co_filename = co.co_filename
    self.co_firstlineno = co.co_firstlineno
    self.co_flags = co.co_flags
    self.co_lnotab = co.co_lnotab
    self.co_name = co.co_name
    self.co_names = co.co_names
    self.co_nlocals = co.co_nlocals
    self.co_stacksize = co.co_stacksize
    self.co_varnames = co.co_varnames
</code></pre>
</div>

<p>The _modifiable attribute is there to prevent trying (or succeeding!)
to modify bytecode that may have been produced by Python or some other
mechanism. Everything else comes straight from the documentation.</p>

<p>Now for the append function. We could require the user to manage the
constants table, and the other tables, separately. But that would be
horrible! So we&#39;ll automate the management as much as we can using the
data from the opcode module about what opcodes take what kind of
arguments. In <em>pseudo-code:</em></p>
<div class="highlight"><pre><code class="text">def append(self, opname, arg=None):
opnum = opcode.opmap[opname]
if op &lt; opcode.HAVE_ARGUMENT:
    if arg is not None:
    bad argument
    else
    co_code.append(opnum)
else:
    if argument-type(op) is &#39;constant&#39;:
    if arg is in self.co_consts:
        argval = self.co_consts.index(arg)
    else:
        argval = len(self.co_consts)
        self.co_consts.append(arg)
    elif argument-type(op) is &#39;name&#39;:
    if arg is in self.co_names:
        argval = self.co_names.index(arg)
    else:
        argval = len(self.co_names)
        self.co_names.append(arg)

    elif argument-type(op) is &#39;relative-jump&#39; or argument_type(op) is &#39;absolute-jump&#39;:
    # Handle these differently
    pass
</code></pre>
</div>

<p>In any other language, that would be a &#39;switch&#39; statement. And switching
is one of those things that tell us we are missing a class/subclass
hierarchy. So what are we missing? Well, the behavior is determined by
the opcode, and the opcode is either a string, or equivalently, a number
between 0 and 255. Some of those numbers are invalid. Others are no-arg
opcodes, and still others are opcodes that take names, or constants, or
jumps, or whatever. So there are potentially 256 different behaviors, or
<em>strategies</em> that we can access by indexing into a densely-packed array.</p>

<p>Let&#39;s try coding a few of those behaviors. We&#39;ll assume that each method
gets the opcode (a number), and the argument or None:</p>
<div class="highlight"><pre><code class="text">def _append_invalid_opcode(self, opnum, arg):
    raise &quot;Invalid opcode specified: %d&quot; % opnum

def _append_opcode_noarg(self, opnum, arg):
    self.append_bytecode(opnum)

def _append_opcode_const(self, opnum, arg):
    try:
        arg_index = self.co_consts.index(arg)
    except IndexError:
        arg_index = len(self.co_consts)
        self.co_consts.append(arg)
    self.append_bytecode(opnum, arg_index)

def _append_compare_op(self, opnum, arg):
    try:
        arg_index = opcode.cmp_op.index(arg)
    except IndexError:
        raise &quot;Invalid compare operation: &#39;%s&#39;&quot; % arg
</code></pre>
</div>

<p>When we express things this way, they&#39;re nice and clear. All we have to
do is populate an opcode-number-to-method table, and make sure to define
all the possible behaviors. Since we have a nice default value, we can
leave that in place until we are ready to use a particular group of
opcodes. The class definition code can handle the table, since this
behavior won&#39;t change from object to object. And we can make append very
simple this way! I&#39;m going to add one more thing -- a list of the
opcodes that have been appended. We&#39;ll use this for a little bit in
order to debug the appender.</p>
<div class="highlight"><pre><code class="text">class CodeObject:
    # ...
    def __init__(self, ...):
        # ...
        self._appended_ops = []

    # ...
    _append_dispatch = [ _append_invalid_opcode ] * 256

    _strategy_ops = {
        _append_opcode_noarg: [x for x in range(opcode.HAVE_ARGUMENT - 1) if not opcode.opname[x].startswith(&#39;&lt;&#39;)]
        _append_opcode_compare: opcode.hascompare,
        _append_opcode_const: opcode.hasconst,
        _append_opcode_freevar: opcode.hasfree,
        _append_opcode_jumpabs: opcode.hasjabs,
        _append_opcode_jumprel: opcode.hasjrel,
        _append_opcode_localvar: opcode.haslocal,
        _append_opcode_name: opcode.hasname,
        _append_opcode_numargs: opcode.hasnargs,
    }

    for behavior, oplist in _strategy_ops.items():
        for op in oplist:
            _append_dispatch[op] = behavior

    def append(self, opname, arg=None):
        if not self._modifiable:
            raise TypeError(&quot;Cannot append to unmodifiable object.&quot;)
        opnum = opcode.opmap[opname]
        self._appended_ops.append((opname, opnum, arg))
        meth = self._append_dispatch[opnum].__get__(self, CodeObject)
        meth(opnum, arg)

    def append_bytecode(self, opnum, arg):
        bytes = self.co_code
        if opnum &gt;= opcode.HAVE_ARGUMENT:
            if arg &gt; 0xFFFF:
                self.append_bytecode(opcode.EXTENDED_ARG, arg &gt;&gt; 16)
            bytes.append(opnum)
            bytes.append(arg &amp; 0xFF)
            bytes.append((arg&gt;&gt;8) &amp; 0xFF)
        else:
            bytes.append(opnum)
</code></pre>
</div>

<p>At this point we have two remaining steps to work on. First, the
strategy methods are not all implemented. That won&#39;t be a problem for
our first test, since we (think we) already have the methods implemented
that the first test case will use. Second, and more importantly, we
don&#39;t have a assertInstructions method at all. So let&#39;s look at what
will be required to implement that.</p>

<h3 id="toc_3705">Fetching the Bytecodes</h3>

<p>The purpose of the assertInstructions method is to confirm that the
bytecode data we have in our object is consistent with the bytecodes
contained in one or more opcode strings (or tuples or something) we
provide. All of the other fields in the CodeObject -- the co_consts,
co_names, the line number table -- all of those are maintained to
support the bytecodes that are contained in the bytearray object stored
in co_code.</p>

<p>Checking bytecodes, then, consists of reading through the bytecode list
and decoding each operation in sequence. Sometimes the opcodes will
require an argument, which will come from the bytecode list as well.
Resolving the argument may involve some of the other tables. Depending
on the sequence, resolving a single opcode may require one, three, or
six bytes of data from the bytecode stream.</p>

<p>This means that we cannot simply iterate over the bytecode data.
Decoding consumes a variable number of bytes per opcode. So we need some
iterator object between the comparison code and the bytes. That iterator
will have the job of decoding the variable-length opcodes into a series
of tuples. (I considered storing the tuples, instead of bytes, but then
we couldn&#39;t use other compiled functions to initialize our objects.)</p>

<p>We want an opcode enumerator, or iterator, that will resolve all of
fields in a typical dis disassembly. That means the opcode name, the
argument index, and the argument value if it requires a lookup.</p>

<p>Doing all that means that the iterator will need access to our entire
CodeObject -- it&#39;s not enough to have a stream of byte codes. That&#39;s a
good argument for providing a factory method returning an iterator,
instead of just providing an iterator class. We&#39;ll try something like
co.instructions() in the style of dict.keys(), dict.values(), and
dict.items().</p>

<p>Our iterator is going to have to iterate over the bytes in the co_code
array doing the decode work. Given a byte to decode, we will have to
implement some kind of n-way switch on the value of the byte to
determine the decoding logic. That is a mirror image of the switch we
were looking at in the append() logic, above. So let&#39;s plan to solve
this problem in the same way -- use a table of methods instead of a
switch or giant if/elif/else block. We can return a tuple of: line
number, offset, labels, opcode number, opcode name, argument index, and
argument value. That should make it a snap to compare our object with a
user-specified sequence of byte codes.</p>
<div class="highlight"><pre><code class="text">def _decode_argindex(self, it, extended_arg):
    &quot;&quot;&quot;Decodes an argument index, including support for extended_arg.&quot;&quot;&quot;
    argindex = next(it)
    argindex |= next(it) &lt;&lt; 8
    if extended_arg is not None:
        argindex |= extended_arg &lt;&lt; 16
    return argindex

def _decode_common(self, opnum, offset):
    lineno = self.get_lineno_of_offset(offset)
    labels = self.get_labels_at_offset(offset)
    opname = opcode.opname[opnum]
    return (lineno, labels, opname)

def _decode_invalid_opcode(self, opnum, it, offset, extended_arg):
    opname = opcode.opname[opnum]
    raise ValueError(&quot;Unknown opcode &#39;%s&#39; at offset %d&quot; % (opname, offset))

def _decode_opcode_noarg(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    lineno, labels, opname = self._decode_common(opnum, offset)
    argvalue = argindex = None
    return (lineno, offset, labels, opnum, opname, argindex, argvalue)

def _decode_opcode_hasconst(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    lineno, labels, opname = self._decode_common(opnum, offset)
    argindex = self._decode_argindex(it, extended_arg)
    argvalue = self.co_consts[argindex]
    return (lineno, offset, labels, opnum, opname, argindex, argvalue)

def _decode_opcode_compare(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    lineno, labels, opname = self._decode_common(opnum, offset)
    argindex = self._decode_argindex(it, extended_arg)
    argvalue = opcode.cmp_op[argindex]
    return (lineno, offset, labels, opnum, opname, argindex, argvalue)

def _decode_opcode_const(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    lineno, labels, opname = self._decode_common(opnum, offset)
    argindex = self._decode_argindex(it, extended_arg)
    argvalue = self.co_consts[argindex]
    return (lineno, offset, labels, opnum, opname, argindex, argvalue)

def _decode_opcode_freevar(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    raise NotImplementedError(&quot;not yet&quot;)

def _decode_opcode_jumpabs(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    raise NotImplementedError(&quot;not yet&quot;)

def _decode_opcode_jumprel(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    raise NotImplementedError(&quot;not yet&quot;)

def _decode_opcode_localvar(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    raise NotImplementedError(&quot;not yet&quot;)

def _decode_opcode_name(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    raise NotImplementedError(&quot;not yet&quot;)

def _decode_opcode_numargs(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    raise NotImplementedError(&quot;not yet&quot;)

_decode_dispatch = [ _decode_invalid_opcode ] * 256
_decode_strategy = {
    _decode_opcode_noarg  : [ x for x in range(opcode.HAVE_ARGUMENT - 1) ],
    _decode_opcode_compare: opcode.hascompare,
    _decode_opcode_const  : opcode.hasconst,
    _decode_opcode_freevar: opcode.hasfree,
    _decode_opcode_jumpabs: opcode.hasjabs,
    _decode_opcode_jumprel: opcode.hasjrel,
    _decode_opcode_localvar: opcode.haslocal,
    _decode_opcode_name   : opcode.hasname,
    _decode_opcode_numargs: opcode.hasnargs,
}

for strategy, oplist in _decode_strategy.items():
    for op in oplist:
        _decode_dispatch[op] = strategy

def get_lineno_of_offset(self, offset):
    return 1

def get_labels_at_offset(self, offset):
    return ()

def instructions(self):
    &quot;&quot;&quot;Return a series of tuples representing individual instructions
    decoded from self.co_code. Tuples will be composed of:
    (lineno, offset, labels, opnum, opname, argindex, argvalue)
    &quot;&quot;&quot;
    it = iter(self.co_code)
    offset = 0
    extended_arg = None
    while True:
        opnum = next(it)
        offset += 1
        meth = self._decode_dispatch[opnum].__get__(self)
        tpl = meth(opnum, it, offset, extended_arg)
        if tpl[3] == opcode.EXTENDED_ARG:
            extended_arg = tpl[5]
        else:
            extended_arg = None
        yield tpl
</code></pre>
</div>

<p>At last, we come to the business of actually comparing bytecode
instructions with some kind of user input! The interface for this
function will be fairly simple: if the bytecode stream matches the user
specification, it will return true. Otherwise, it will raise an
exception. Most unit testing frameworks catch exceptions, so users can
pretty safely just call our function, or they could put in a fancy
wrapper.</p>

<p>The job of this function is to compare a CodeObject&#39;s bytecode with an
input sequence, and determine if it matches. The input will be a
CodeObject and a long text string containing the matched instruction
string. We&#39;ll have to parse the text string into a series of matchables,
then compare those against the stream of results we get back from the
=instructions()= of the CodeObject. Parsing the text is a great place to
let a regex do most of our work for us.</p>
<div class="highlight"><pre><code class="text">import re

_Match_line_re = re.compile(
    r&#39;\s* (?P&lt;lineno&gt; \d+ )? \s* (?P&lt;offset&gt; \d+ )?&#39; \
    r&#39;\s* (?P&lt;opname&gt; [A-Z]\w* )&#39; \
    r&#39;\s* ( (?P&lt;argindex&gt; \d+ )&#39; \
        r&#39;\s* (?: \( (?P&lt;argvalue&gt; [^)]* ) \) )? )?&#39;,
    re.X)

def instructions_match(co, text):
    &quot;&quot;&quot;
    Determine if a CodeObject&#39;s instruction stream matches a list of
    Python opcodes. Return True if the instructions match. Raise an
    exception if an error or mismatch occurs.
    &quot;&quot;&quot;
    def assert_match(wanted, got, field, line):
        if wanted is None:
            return
        if wanted.isdigit():
            wanted = int(wanted)
        if wanted != got:
            raise ValueError(&quot;Mismatch in &#39;%s&#39; at line &#39;%s&#39;: %s != %s&quot; \
                % (field, line, wanted, got))
    instr = co.instructions()
    for line in text.splitlines():
        line = line.strip()
        if line == &#39;&#39;:
            continue
        m = _Match_line_re.match(line)
        if not m:
            raise ValueError(&quot;Unparseable format in line: &#39;%s&#39;&quot; % line)
        match = m.groupdict()
        try:
            (lineno, offset, labels, opnum, opname, argindex, argvalue) \
                = next(instr)
        except StopIteration:
            raise ValueError(&quot;Reached end of bytecode at line &#39;%s&#39;&quot; \
                % line)
        assert_match(match[&#39;offset&#39;], offset, &#39;offset&#39;, line)
        assert_match(match[&#39;opname&#39;], opname, &#39;opname&#39;, line)
        assert_match(match[&#39;argindex&#39;], argindex, &#39;argindex&#39;, line)
        if match[&#39;argvalue&#39;] is not None:
            mval = match[&#39;argvalue&#39;]
            if mval.startswith(&#39;&quot;&#39;) or mval.startswith(&quot;&#39;&quot;):
                mval = mval[1:-1]
            assert_match(mval, argvalue, &#39;argvalue&#39;, line)
    # If we run out of lines, return True.
    return True
</code></pre>
</div>

<h3 id="toc_3706">A Bug is Discovered</h3>

<p>Running this code produces one surprising result:</p>
<div class="highlight"><pre><code class="text">import bytecode

def main():
    co = bytecode.CodeObject()
    co.append(&#39;LOAD_CONST&#39;, 42)
    co.append(&#39;RETURN_VALUE&#39;)
    asm = &quot;&quot;&quot;
        LOAD_CONST 1 (42)
        RETURN_VALUE
    &quot;&quot;&quot;
    print(bytecode.instructions_match(co, asm))

if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
</div>

<p>I got this:</p>
<div class="highlight"><pre><code class="text">Traceback (most recent call last):
  File &quot;./test.py&quot;, line 36, in &lt;module&gt;
    main()
  File &quot;./test.py&quot;, line 32, in main
    print(bytecode.instructions_match(co, asm))
  File &quot;/Users/austin/git/lbac/ch03/bytecode.py&quot;, line 296, in instructions_match
    assert_match(match[&#39;argindex&#39;], argindex, &#39;argindex&#39;, line)
  File &quot;/Users/austin/git/lbac/ch03/bytecode.py&quot;, line 278, in assert_match
    % (field, line, wanted, got))
ValueError: Mismatch in &#39;argindex&#39; at line &#39;LOAD_CONST 1 (42)&#39;: 1 != 0
</code></pre>
</div>

<p>The problem is the &#39;LOAD_CONST&#39; argument index. According to the
output, we are asking for index # 1, but the system is returning index
# 0. What gives?</p>

<p>In fact, if I start up Python and try typing in our favorite function, I
get a similar behavior. :</p>
<div class="highlight"><pre><code class="text">Python 3.3.0 (default, Nov 23 2012, 10:26:01)
[GCC 4.2.1 Compatible Apple Clang 4.1 ((tags/Apple/clang-421.11.66))] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; def f():
...     return 42
...
&gt;&gt;&gt; f.__code__.co_consts
(None, 42)
</code></pre>
</div>

<p>It appears that the [0] slot in the .co_consts tuple is always a None
value. This is confirmed when we try an even smaller function
definition:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; def g():
...     pass
...
&gt;&gt;&gt; g.__code__.co_consts
(None,)
</code></pre>
</div>

<p>This is a pretty easy fix. We&#39;ll just change the <strong>init</strong> code for
the CodeObject class. But this is exactly the sort of &quot;learning about
the environment&quot; I warned you about, before. Every architecture, no
matter how well designed, is going to have these little quirks. When
you&#39;re writing a compiler, you need to expect them. Seek them out, and
try to get some benefit out of them -- presumably they were put in for a
reason.</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; attrs=[x for x in dir(g.__code__) if not x.startswith(&#39;_&#39;)]
&gt;&gt;&gt; [ (x, getattr(g.__code__, x)) for x in attrs]
[(&#39;co_argcount&#39;, 0), (&#39;co_cellvars&#39;, ()), (&#39;co_code&#39;, b&#39;d\x00\x00S&#39;),
(&#39;co_consts&#39;, (None,)), (&#39;co_filename&#39;, &#39;&lt;stdin&gt;&#39;), (&#39;co_firstlineno&#39;, 1),
(&#39;co_flags&#39;, 67), (&#39;co_freevars&#39;, ()), (&#39;co_kwonlyargcount&#39;, 0),
(&#39;co_lnotab&#39;, b&#39;\x00\x01&#39;), (&#39;co_name&#39;, &#39;g&#39;), (&#39;co_names&#39;, ()),
(&#39;co_nlocals&#39;, 0), (&#39;co_stacksize&#39;, 1), (&#39;co_varnames&#39;, ())]
</code></pre>
</div>

<p>I have no idea what &#39;67&#39; means for the flags. Presumably we&#39;ll find out
as we go along. The various fields being set to 0 or () make sense. The
co_stacksize setting of 1 doesn&#39;t make sense, until you realize that
the pass statement expands into return None.</p>

<p>Changing the <strong>init</strong> function to use [None] as the initial value
for co_consts causes our test case to work, though. So I think we can
proceed.</p>

<h2 id="toc_3707">Writing More Test Cases</h2>

<p>Now that we have a working framework for writing and passing test cases,
let&#39;s write some expressions and try to predict how they will be coded.
We&#39;ll have to use input parameters when we deal with the Python
compiler, because it automatically replaces constant expressions with
their result. What&#39;s worse, Python apparently optimizes <em>after</em> it addes
the constants to the .co_consts table:</p>
<div class="highlight"><pre><code class="text">    &gt;&gt;&gt; def f():
    ...     return 8/2+3*4-6/1
    ...
    &gt;&gt;&gt; f.__code__.co_consts
    (None, 8, 2, 3, 4, 6, 1, 4.0, 12, 16.0, 6.0, 10.0)
    &gt;&gt;&gt; da(f)
      2           0 LOAD_CONST              11 (10.0)
                  3 RETURN_VALUE
</code></pre>
</div>

<p>From this, we&#39;re learning that the constants table will contain a mix of
constants and possibly interim results. Yikes! That makes predicting the
argindex a little challenging. (Good thing we don&#39;t have to specify it!)</p>

<p>So let&#39;s use parameters, instead of constants. That way we&#39;ll force the
Python compiler to generate the various operations, instead of just the
interim results:</p>
<div class="highlight"><pre><code class="text">    &gt;&gt;&gt; def f(a,b,c,d):
    ...     return a*b-c/d
    ...
    &gt;&gt;&gt; da(f)
      2           0 LOAD_FAST                0 (a)
                  3 LOAD_FAST                1 (b)
                  6 BINARY_MULTIPLY
                  7 LOAD_FAST                2 (c)
                 10 LOAD_FAST                3 (d)
                 13 BINARY_TRUE_DIVIDE
                 14 BINARY_SUBTRACT
                 15 RETURN_VALUE
</code></pre>
</div>

<p>Can we use this for a test case? Sure! Let&#39;s give it a try:</p>
<div class="highlight"><pre><code class="text">    &gt;&gt;&gt; from ch03 import bytecode
    &gt;&gt;&gt; co = bytecode.CodeObject(f)
    &gt;&gt;&gt; expected = &quot;&quot;&quot;
    ...   2           0 LOAD_FAST                0 (a)
    ...               3 LOAD_FAST                1 (b)
    ...               6 BINARY_MULTIPLY
    ...               7 LOAD_FAST                2 (c)
    ...              10 LOAD_FAST                3 (d)
    ...              13 BINARY_TRUE_DIVIDE
    ...              14 BINARY_SUBTRACT
    ...              15 RETURN_VALUE
    ... &quot;&quot;&quot;
    &gt;&gt;&gt; bytecode.instructions_match(co, expected)
    Traceback (most recent call last):
      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
      File &quot;/Users/austin/git/lbac/ch03/bytecode.py&quot;, line 291, in instructions_match
        = next(instr)
      File &quot;/Users/austin/git/lbac/ch03/bytecode.py&quot;, line 256, in instructions
        tpl = meth(opnum, it, offset, extended_arg)
      File &quot;/Users/austin/git/lbac/ch03/bytecode.py&quot;, line 213, in _decode_opcode_localvar
        raise NotImplementedError(&quot;not yet&quot;)
    NotImplementedError: not yet
</code></pre>
</div>

<p>Oh, no! An exception! But wait. It&#39;s a &quot;not implemented yet&quot; exception!
Our code is working fine -- we just haven&#39;t written enough of it. In
particular, the _decode_opcode_localvar subroutine is a stub. Let&#39;s
have a look at that:</p>
<div class="highlight"><pre><code class="text">    &gt;&gt;&gt; import opcode
    &gt;&gt;&gt; [ x for x in opcode.haslocal]
    [124, 125, 126]
    &gt;&gt;&gt; [ opcode.opname[x] for x in opcode.haslocal]
    [&#39;LOAD_FAST&#39;, &#39;STORE_FAST&#39;, &#39;DELETE_FAST&#39;]
</code></pre>
</div>

<p>So we&#39;re missing three opcodes, and one of them -- LOAD_FAST is used a
lot in our function. Checking the Python documentation <a href="http://docs.python.org/3/library/dis.html#opcode-LOAD_FAST"><sup>3</sup></a> we find this
description:</p>
<div class="highlight"><pre><code class="text">&gt; *LOAD_FAST(var_num)*
&gt; :   Pushes a reference to the local co_varnames[var_num] onto the
&gt;     stack.
&gt;
</code></pre>
</div>

<p>So let&#39;s add that to our code:</p>
<div class="highlight"><pre><code class="text">def _decode_opcode_localvar(self, opnum, it, offset, extended_arg):
    &quot;&quot;&quot;Return a tuple of (lineno, offset, (labels), opnum, opname,
    argindex, argvalue).&quot;&quot;&quot;
    lineno, labels, opname = self._decode_common(opnum, offset)
    argindex = self._decode_argindex(it, extended_arg)
    argvalue = self.co_varnames[argindex]
    return (lineno, offset, labels, opnum, opname, argindex, argvalue)
</code></pre>
</div>

<h3 id="toc_3708">Another Bug is Found</h3>

<p>With that change, I get a new failure:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; bc.instructions_match(co, expected)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
  File &quot;/Users/austin/git/lbac/ch03/bytecode.py&quot;, line 298, in instructions_match
    assert_match(int(match[&#39;offset&#39;]), offset, &#39;offset&#39;, line)
  File &quot;/Users/austin/git/lbac/ch03/bytecode.py&quot;, line 282, in assert_match
    % (field, line, wanted, got))
ValueError: Mismatch in &#39;offset&#39; at line &#39;2           0 LOAD_FAST                0 (a)&#39;: 0 != 1
</code></pre>
</div>

<p>Apparently, there&#39;s some kind of off-by-one error in our offset
handling. And sure enough, here it is:</p>
<div class="highlight"><pre><code class="text">def instructions(self):
    it = iter(self.co_code)
    offset = 0
    extended_arg = None
    while True:
        opnum = next(it)
        offset += 1
        meth = self._decode_dispatch[opnum].__get__(self)
        tpl = meth(opnum, it, offset, extended_arg)
        if tpl[3] == opcode.EXTENDED_ARG:
            extended_arg = tpl[5]
        else:
            extended_arg = None
        yield tpl
</code></pre>
</div>

<p>Looking hard at the code, I can see where I incremented offset. And two
lines later, I see where I use it. Let&#39;s just move the increment down
after the fall to meth() and try again:</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; bc.instructions_match(co, expected)
True
</code></pre>
</div>

<h2 id="toc_3709">But Does it Run?</h2>

<p>Presently, our bytecode module handles function parameters (which is
more than our parser from chapter 2 does!) and all of the no-argument
opcodes. Because the Python VM is stack based, all the math operations
are no-argument opcodes. They assume that their operands are already on
the stack, and they leave their results on the stack. Just a little bit
of coding here has carried us a long way!</p>

<p>But there is one last hurdle that we need to clear. One more thing that
we just have to have before we can wrap this up: we need bytecode that
we can actually <em>run!</em></p>

<p>So far, all the work we have done has filled up an array of bytes. And
our test cases agree, those bytes do appear to be the exact set of bytes
that we want. But that&#39;s no quite as satisfying as being able to call a
function from our Python and have it work. So let&#39;s do that.</p>

<h3 id="toc_3710">From Code to Function</h3>

<p>A little bit of Google will take you to the =exec()= documentation in
Python, which explicitly states, &quot;This function can also be used to
execute arbitrary code objects (such as those created by compile()).&quot;
Well, that&#39;s pretty clear. But I don&#39;t want to return a binary thing
that has to be passed to =exec().= At least, not yet. I want a
<em>function!</em></p>

<p>A little more Google leads us to =FunctionType,= defined in the =types=
module. In the Django sources, there are some examples of creating a
function using the =FunctionType(...)= constructor. Running
=pydoc types.FunctionType= shows a definition like this:</p>
<div class="highlight"><pre><code class="text">types.FunctionType = class function(object)
|  function(code, globals[, name[, argdefs[, closure]]])
|
|  Create a function object from a code object and a dictionary.
|  The optional name string overrides the name from the code object.
|  The optional argdefs tuple specifies the default argument values.
|  The optional closure tuple supplies the bindings for free variables. `=\=
</code></pre>
</div>

<p>If I read this right, the =function()= constructor is renamed to
=FunctionType= in the module. And it can be called with a code object, a
dictionary of globals, and some other stuff that is optional. Let&#39;s try
that in the interpreter.</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; def f():
...     print(&quot;Hello, world!&quot;)
...
&gt;&gt;&gt; co = f.__code__
&gt;&gt;&gt; import types
&gt;&gt;&gt; newfn = types.FunctionType(co, globals(), &#39;newfie&#39;)
&gt;&gt;&gt; newfn.__name__
&#39;newfie&#39;
&gt;&gt;&gt; newfn()
Hello, world!
</code></pre>
</div>

<p>Well, THAT works just fine. We could add that as a helper function, but it&#39;s
only one line - let&#39;s just remember it for a bit.</p>

<p>Next comes the issue of how to convert our <em>simulated</em> class, =CodeObject,=
into an actual =code object.= Sure enough, there is a
=types.CodeType= defined, and it has a help page. The constructor is a
little complex:</p>
<div class="highlight"><pre><code class="text">types.CodeType = class code(object)
|  code(argcount, kwonlyargcount, nlocals, stacksize, flags, codestring,
|        constants, names, varnames, filename, name, firstlineno,
|        lnotab[, freevars[, cellvars]])
|
|  Create a code object.  Not for the faint of heart.
</code></pre>
</div>

<p>So, as long as we get the <strong>thirteen</strong> (!!!) positional arguments correct,
it shouldn&#39;t be any trouble at all. (This is one of those times when named
arguments make a huge amount of sense.)</p>

<p>I&#39;ll tell it the stacksize is &quot;2&quot;, since that seems safe - we&#39;re only
pushing one thing on the stack, so it should be twice as much space as we
need.</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; from ch03 import bytecode
&gt;&gt;&gt; co = bytecode.CodeObject()
&gt;&gt;&gt; co.append(&#39;LOAD_CONST&#39;, 77)
&gt;&gt;&gt; co.append(&#39;RETURN_VALUE&#39;)
&gt;&gt;&gt; import types
&gt;&gt;&gt; code_type = types.CodeType(0, 0, 0, 2, 0, co.co_code, co.co_consts, names=[], varnames=[], filename=&#39;input&#39;, name=&#39;test_code_type&#39;, firstlineno=1, lnotab=[])
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: code() takes at least 13 arguments (7 given)
&gt;&gt;&gt; code_type = types.CodeType(0, 0, 0, 2, 0, co.co_code, co.co_consts, [], [], &#39;input&#39;, &#39;test_code_type&#39;, 1, [])
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: must be bytes, not bytearray &gt;&gt;&gt; code_type = types.CodeType(0, 0, 0, 2, 0, bytes(co.co_code), co.co_consts, [], [], &#39;input&#39;, &#39;test_code_type&#39;, 1, [])
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: must be tuple, not list
&gt;&gt;&gt; code_type = types.CodeType(0, 0, 0, 2, 0, bytes(co.co_code), co.co_consts, (), (), &#39;input&#39;, &#39;test_code_type&#39;, 1, [])
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: must be tuple, not list
&gt;&gt;&gt; code_type = types.CodeType(0, 0, 0, 2, 0, bytes(co.co_code), co.co_consts, (), (), &#39;input&#39;, &#39;test_code_type&#39;, 1, ())
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: must be tuple, not list
&gt;&gt;&gt; code_type = types.CodeType(0, 0, 0, 2, 0, bytes(co.co_code), tuple(co.co_consts), (), (), &#39;input&#39;, &#39;test_code_type&#39;, 1, ())
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: must be bytes, not tuple
&gt;&gt;&gt; code_type = types.CodeType(0, 0, 0, 2, 0, bytes(co.co_code), tuple(co.co_consts), (), (), &#39;input&#39;, &#39;test_code_type&#39;, 1, bytes())
</code></pre>
</div>

<p>That was frustrating. But we finally have something that might be a code
object we can add to a function. Let&#39;s give that a try (in the same
interpreter session!):</p>
<div class="highlight"><pre><code class="text">&gt;&gt;&gt; newfn = types.FunctionType(code_type, globals(), &#39;return77&#39;)
&gt;&gt;&gt; newfn()
77
</code></pre>
</div>

<p>Woo-hoo!! Now we know how to turn our byte codes into a callable Python
function. Let&#39;s add a =compile()= method to our CodeObject, and we&#39;ll
add a =to_function()= method, as well. Here&#39;s a test case:</p>
<div class="highlight"><pre><code class="text">def test_return77(self):
    co = CodeObject()
    co.append(&#39;LOAD_CONST&#39;, 77)
    co.append(&#39;RETURN_VALUE&#39;)
    ret77 = co.to_function()
    self.assertEqual(77, ret77())
</code></pre>
</div>

<p>And here&#39;s the code I used:</p>
<div class="highlight"><pre><code class="text">def compile(self):
    &quot;&quot;&quot;
    Compile the current state of the object into a Python =CodeType=
    object. Because of data format conversions, this method can be
    called more than once as the object changes.
    Return a new CodeType object.
    &quot;&quot;&quot;
    kwonlyargs =  0
    freevars = ()
    cellvars = ()
    ct = types.CodeType(
        self.co_argcount, kwonlyargs, self.co_nlocals, self.co_stacksize,
        self.co_flags, bytes(self.co_code), tuple(self.co_consts),
        tuple(self.co_names), tuple(self.co_varnames), self.co_filename,
        self.co_name, self.co_firstlineno, bytes(self.co_lnotab),
        freevars, cellvars)
    return ct

def to_function(self, globs=None, name=None, argvals=None, closure=None):
    if globs is None:
        globs = globals()
    code = self.compile()
    return types.FunctionType(code, globs, name, argvals, closure)
</code></pre>
</div>

<p>Presently, our bytecode module handles function parameters (which is
more than our parser from chapter 2 does!) and all of the no-argument
opcodes. Because the Python VM is stack based, all the math operations
are no-argument opcodes. They assume that their operands are already on
the stack, and they leave their results on the stack.</p>

<h2 id="toc_3711">At Last!</h2>

<p>I&#39;m going to draw this chapter to a close. You know that there are a
bunch of not-implemented-yet methods waiting in our code. You also know
that our code is clean enough that filling in those methods will be
straightforward. When we stumble upon an unimplemented method from here
on, we can just fill it in and keep coding.</p>

<p>If you&#39;re following along, there&#39;s one thing the bytecode library can&#39;t
do, now, that I know we&#39;ll eventually need: it doesn&#39;t support all the
opcodes for printing a string. Until those opcodes are added, you can&#39;t
print &quot;Hello, world!&quot; You may want to take a minute to add those.</p>

<p><strong>Footnotes</strong></p>

<!---
vim: set et fileencoding=utf8 sts=4 sw=4 ts=4 tw=76:
-->

  </div>
</div>

    </section>
  </body>
</html>
