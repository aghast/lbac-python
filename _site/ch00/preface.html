<!DOCTYPE HTML>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="author" content="Austin Hastings" />
    <link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/pygments_borland.css" media="screen" rel="stylesheet" type="text/css" />
    <link href="/stylesheets/styles.css" media="screen" rel="stylesheet" type="text/css" />
    <script src="/javascripts/main.js" type="text/javascript"></script>

    <title>Preface: 25 years later</title>
  </head>
  <body>
    <header>
      <h1><a href="/">Preface: 25 years later</a></h1>
    </header>
    <section>
      <div class="content">
  <div id="chapter">
    <h1></h1>
    <h1 id="toc_317">Preface: 25 years later</h1>

<p>I don&#39;t know exactly when he started composing the series, but between
July of 1988 and May of 1995 Jack Crenshaw published a series of
articles titled Let&#39;s Build a Compiler! That series remains perhaps the
best available reference for codes interested in the process of
developing a <em>Language Processor</em> such as a syntax hilighter, SLOC
counter, static analyzer, interpreter or compiler.</p>

<p>Because of the enduring quality of the series, and because I find myself
(25 years later) sharing a lot of interests in common with the Jack
Crenshaw of 1988, I have decided to write my own compiler. And document
the process. To make things a little easier on everyone involved, I
won&#39;t use Borland Turbo Pascal. Instead, I have decided to use Python 3.</p>

<h2 id="toc_318">Scope</h2>

<p>I&#39;m ambitious, but not insane. I want to explore writing a compiler, not
exhaustively cover every possible aspect of the process. What&#39;s more, I
have no desire whatsoever to present any math. This is my writing about
coding, not about mathing. Hell! That&#39;s not even a word.</p>

<p>The idea will be to develop a compiler, plus some supporting tools, that
does what you expect a compiler to do: accept source code of some kind
as input, and emit some kind of compiled code as output.</p>

<p>Unfortunately, at the time of this writing, Python 3 has not been
universally adopted by the Python community. So many of the helper
modules that might be available in 2.x aren&#39;t available to me. So there
may be more &#39;supporting tools&#39; written than you are comfortable with.</p>

<h2 id="toc_319">Structure</h2>

<p>From a very general perspective, a <em>Language Processor</em> does two things:
first it reads in one or more files in a language and builds up some
kind of understanding of the code; and second it uses the understanding
built up in the first part to perform whatever tasks are requested of
it.</p>

<p>Consider a syntax highlighter: a highlighter doesn&#39;t really need to know
about the language, except to identify the boundaries beween words. Once
it knows that a string of characters is an identifier- and not, say, a
key word like &#39;if&#39; or &#39;while&#39;- the &#39;understanding&#39; part is pretty much
done. &quot;Color this one blue!&quot;</p>

<p>My objective, as stated above, is to build a &#39;real compiler&#39;. Not a
syntax highlighter, but a program that will take source code in, and
write some kind of executable out. I&#39;m willing to settle for
<em>translating</em> the code to a much lower level (writing out assembly files
instead of compiled objects) but that&#39;s about it.</p>

<p>The structure, then, will be &quot;the full monty&quot;. If you&#39;ve dabbled with
compilers before, you&#39;ll recognize the stages: lexer, parser, tree,
optimizer, code generator. I want to touch on all of those in this
series.</p>

<p>Just like in the Jack Crenshaw&#39;s original series, I expect we&#39;ll have to
take things apart and put them back together a few times. I don&#39;t expect
to start writing code and just emit all the parts in working order.
There is going to be some give and take - in fact, a lot of it.
Hopefully it will help increase my (and your) understanding, and not
just piss you off.</p>

<h3 id="toc_320">Approach</h3>

<p>In all of my reading, I haven&#39;t found much test-driven work around
compilation. That surprises me, since compilers are complicated systems,
and since it can be really hard to guess where a failure is coming from.
So there will be tests, and many of them will be written in advance. I
expect more of them will be written afterwards - I&#39;ll want to set
regression barriers, too.</p>

  </div>
</div>

    </section>
  </body>
</html>
